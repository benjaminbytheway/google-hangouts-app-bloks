<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Blokus</title>
  <style>
    html { width: 100%; height: 100%; }
    body { margin: 0; overflow: hidden; width: 100%; height: 100%; }
    #canvas-container { width: 100%; height: 100%; }
    canvas { width: 100%; height: 100%; }
    #view-1 { position: fixed; top: 10px; left: 10px; }
    #view-2 { position: fixed; top: 10px; left: 60px; }
    #view-3 { position: fixed; top: 10px; left: 110px; }
  </style>
  <script src="three.js"></script>
  <script src="TrackBallControls.js"></script>
  <script src="OBJLoader.js"></script>
</head>
  <body>
    <div id="canvas-container">
      <button id="view-1">View 1</button>
      <button id="view-2">View 2</button>
      <button id="view-3">View 3</button>
    </div>
    <script>
      // TODO: TrackBallControlls and how it affects that camera views 1, 2, and 3...

      'use strict';

      var
        w = window,
        d = document,
        container = d.getElementById('canvas-container'),
        // three
        scene,
        camera,
        view1,
        view2,
        view3,
        renderer,
        directionalLight,
        ambientLight,
        raycaster,
        plane,
        offset,
        intersection,
        mouse,
        controls,
        loader,
        // game objects
        tableMesh,
        tableGeometry,
        tableMaterial,
        boardSquareMesh,
        boardSquareGeometryTemplate,
        boardSquareMaterial,
        group,
        squareMesh,
        squareGeometryTemplate,
        squareMaterial,
        // other
        i, l,
        j, jl,
        hoverables = [],
        selectables = [],
        intersected,
        selected,
        // dimensions
        WIDTH = container.offsetWidth,
        HEIGHT = container.offsetHeight,
        SQUARE_WIDTH = 0.2,
        SQUARE_HEIGHT = 0.2,
        SQUARE_DEPTH = 0.02,
        BOARD_WIDTH_IN_SQUARES = 20,
        BOARD_HEIGHT_IN_SQUARES = 20,
        TABLE_WIDTH = 10,
        TABLE_HEIGHT = 10;

      //------------------------------------------------------------------
      // renderer
      //------------------------------------------------------------------
      renderer = new THREE.WebGLRenderer();
      renderer.setSize(WIDTH, HEIGHT);
      renderer.setClearColor(0xffffff);
      renderer.shadowMap.enabled = true;

      //------------------------------------------------------------------
      // scene
      //------------------------------------------------------------------
      scene = new THREE.Scene();

      //------------------------------------------------------------------
      // camera
      //------------------------------------------------------------------
      camera = new THREE.PerspectiveCamera(
        45, 
        WIDTH/HEIGHT, 
        0.1, 
        1000
      );

      camera.position.x = 5;
      camera.position.y = 5;
      camera.position.z = 5;

      camera.lookAt(new THREE.Vector3(0,0,0));

      // listeners
      view1 = d.getElementById('view-1');
      view2 = d.getElementById('view-2');
      view3 = d.getElementById('view-3');

      view1.addEventListener('click', function (evt) {
        camera.position.x = 0;
        camera.position.y = 10;
        camera.position.z = 0;

        camera.lookAt(new THREE.Vector3(0,0,0));
      });

      view2.addEventListener('click', function (evt) {
        camera.position.x = 0;
        camera.position.y = 4;
        camera.position.z = 6;
        
        camera.lookAt(new THREE.Vector3(0,0,0));
      });

      view3.addEventListener('click', function (evt) {
        camera.position.x = 5;
        camera.position.y = 5;
        camera.position.z = 5;
        
        camera.lookAt(new THREE.Vector3(0,0,0));
      });

      // resize if the window gets resized
      w.addEventListener('resize', function () {

        WIDTH = container.offsetWidth;
        HEIGHT = container.offsetHeight;
        
        // update the camera
        camera.aspect = WIDTH / HEIGHT;
        camera.updateProjectionMatrix();

        // update the renderer
        renderer.setSize(WIDTH, HEIGHT);
        
      }, false);

      //------------------------------------------------------------------
      // controls
      //------------------------------------------------------------------
      controls = new THREE.TrackballControls(camera);
      controls.rotateSpeed = 1.0;
      controls.zoomSpeed = 1.2;
      controls.panSpeed = 0.3;
      controls.noZoom = false;
      controls.noPan = false;
      controls.staticMoving = false;
      controls.dynamicDampingFactor = 0.3;

      //------------------------------------------------------------------
      // lights
      //------------------------------------------------------------------
      directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
      directionalLight.position.set(50, 150, 50);
      directionalLight.castShadow = true;
      scene.add(directionalLight);

      ambientLight = new THREE.AmbientLight(0x505050);
      scene.add(ambientLight);

      //------------------------------------------------------------------
      // Table
      //------------------------------------------------------------------
      // tableGeometry = new THREE.PlaneGeometry(TABLE_WIDTH, TABLE_HEIGHT);
      // tableMaterial = new THREE.MeshStandardMaterial({
      //   color: 0xeeeeee,
      //   side: THREE.BackSide
      // });
      // tableMesh = new THREE.Mesh(tableGeometry, tableMaterial);

      // tableMesh.position.y = -1;

      // tableMesh.rotation.x = 0.5 * Math.PI;

      // tableMesh.castShadow = false;
      // tableMesh.receiveShadow = true;

      // scene.add(tableMesh);

      //------------------------------------------------------------------
      // Board
      //------------------------------------------------------------------
      boardSquareGeometryTemplate = new THREE.PlaneGeometry(SQUARE_WIDTH, SQUARE_HEIGHT);

      for (i = 0, l = BOARD_WIDTH_IN_SQUARES; i < l; i++) {
        for (j = 0, jl = BOARD_HEIGHT_IN_SQUARES; j < jl; j++) {
          boardSquareMaterial = new THREE.MeshPhongMaterial({
            color: 0xfcfcfc,
            side: THREE.DoubleSide
          });
          boardSquareMesh = new THREE.Mesh(boardSquareGeometryTemplate, boardSquareMaterial);

          boardSquareMesh.position.x = (i * SQUARE_WIDTH) - ((BOARD_WIDTH_IN_SQUARES * SQUARE_WIDTH) / 2);
          boardSquareMesh.position.z = (j * SQUARE_HEIGHT) - ((BOARD_HEIGHT_IN_SQUARES * SQUARE_HEIGHT) / 2);

          boardSquareMesh.rotation.x = 0.5 * Math.PI;

          boardSquareMesh.castShadow = true;
          boardSquareMesh.receiveShadow = false;

          hoverables.push(boardSquareMesh);

          scene.add(boardSquareMesh);
        }
      }

      //------------------------------------------------------------------
      // Blocks
      //------------------------------------------------------------------
      var block = {
          layout: [
            [0, 1, 1],
            [1, 1, 0],
            [0, 1, 0]
          ],
          color: 0x00ff00
        },
        row,
        square;

      group = new THREE.Group();

      group.userData.block = block;

      for (i = 0, l = block.layout.length; i < l; i++) {
        row = block.layout[i];

        for (j = 0, jl = row.length; j < jl; j++) {
          square = row[j];

          if (square) {
            squareGeometryTemplate = new THREE.BoxGeometry(SQUARE_WIDTH, SQUARE_DEPTH, SQUARE_HEIGHT);
            squareMaterial = new THREE.MeshPhongMaterial({
              color: block.color,
              transparent: true,
              opacity: 0.5,
              shininess: 75,
              side: THREE.DoubleSide
            });
            squareMesh = new THREE.Mesh(squareGeometryTemplate, squareMaterial);

            squareMesh.position.x = i * SQUARE_WIDTH;
            squareMesh.position.z = j * SQUARE_HEIGHT;

            group.add(squareMesh);
          }
            
        }
      }
      
      group.position.y = 0.1;
      group.position.x = 2.2;
      group.position.z = 0;

      group.castShadow = true;
      group.receiveShadow = false;

      hoverables.push(group);
      selectables.push(group);

      scene.add(group);

      //------------------------------------------------------------------
      // Square
      //------------------------------------------------------------------
      // squareGeometryTemplate = new THREE.BoxGeometry(SQUARE_WIDTH, SQUARE_DEPTH, SQUARE_HEIGHT);
      // squareMaterial = new THREE.MeshPhongMaterial({
      //   color: 0xff0000,
      //   transparent: true,
      //   opacity: 0.5,
      //   shininess: 75,
      //   side: THREE.DoubleSide
      // });
      // squareMesh = new THREE.Mesh(squareGeometryTemplate, squareMaterial);

      // squareMesh.position.y = 0.1;
      // squareMesh.position.x = 2.2;
      // squareMesh.position.z = 0;

      // squareMesh.castShadow = true;
      // squareMesh.receiveShadow = false;

      // hoverables.push(squareMesh);
      // selectables.push(squareMesh);

      // scene.add(squareMesh);

      //------------------------------------------------------------------
      // Square with custom mesh
      //------------------------------------------------------------------

      // loader = new THREE.OBJLoader();
      // loader.load(
      //   // resource URL
      //   'src/images/block-1.obj',
      //   // Function when resource is loaded
      //   function (object) {
      //     console.log(object);

      //     squareMesh = object.children[0];
      //     squareMesh.material = new THREE.MeshPhongMaterial({
      //       color: 0xff0000,
      //       transparent: true,
      //       opacity: 0.65,
      //       shininess: 75,
      //       side: THREE.DoubleSide
      //     });

      //     squareMesh.position.y = 0.1;
      //     squareMesh.position.x = 2.2;
      //     squareMesh.position.z = 0;

      //     squareMesh.castShadow = true;
      //     squareMesh.receiveShadow = false;

      //     hoverables.push(squareMesh);
      //     selectables.push(squareMesh);

      //     scene.add(squareMesh);
      //   }
      // );


      //------------------------------------------------------------------
      // Interaction
      //------------------------------------------------------------------
      raycaster = new THREE.Raycaster();
      mouse = new THREE.Vector2();
      plane = new THREE.Plane(new THREE.Vector3(0, 1, 0));
      offset = new THREE.Vector3();
      intersection = new THREE.Vector3();

      function mousemove(e) {
        var
          intersect,
          intersects,
          i, l,
          hoverable;

        e.preventDefault();

        mouse.x = (event.clientX / WIDTH) * 2 - 1;
        mouse.y = -(event.clientY / HEIGHT) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);

        if (selected) {
          
          // move along the x and z plane
          if (raycaster.ray.intersectPlane(plane, intersection)) {
            selected.position.copy(intersection.sub(offset));
          }

          // highlight those hoverables that are in the same x and z coordinate space
          for (i = 0, l = hoverables.length; i < l; i++) {
            hoverable = hoverables[i];

            // reset previous hovers
            if (hoverable.previousColor) {
              hoverable.material.color = hoverable.previousColor;
            }

            // if it is in the same x and z coordinates, change the color
            if (
              Math.floor(hoverable.position.x / SQUARE_WIDTH) === Math.floor((intersection.x - offset.x) / SQUARE_WIDTH) && 
              Math.floor(hoverable.position.z / SQUARE_HEIGHT) === Math.floor((intersection.z - offset.z) / SQUARE_HEIGHT)
            ) {
              hoverable.previousColor = hoverable.material.color;
              hoverable.material.color = new THREE.Color(0xff0000);
            }
          }

        } else {
          intersects = raycaster.intersectObjects(hoverables, true);

          if (intersects.length > 0) {
            intersect = intersects[0];

            if (intersect.object.parent) {
              intersected = intersect.object.parent;
            } else {
              intersected = intersect.object;
            }

            container.style.cursor = 'pointer';

          } else {
            intersected = null;

            container.style.cursor = 'auto';
          }
        }
          
      }

      function mousedown(e) {
        var
          intersect,
          intersects;

        e.preventDefault();

        // NOTE: mouse.x and mouse.y should already be set because it was set above

        raycaster.setFromCamera(mouse, camera);

        intersects = raycaster.intersectObjects(selectables, true);

        if (intersects.length > 0) {
          intersect = intersects[0];

          // disable zoom, pan, etc. while dragging
          controls.enabled = false;

          if (intersect.object.parent) {
            selected = intersect.object.parent;
          } else {
            selected = intersect.object;
          }

          if (raycaster.ray.intersectPlane(plane, intersection)) {
            offset.copy(intersection).sub(selected.position);
          }
        }

        container.style.cursor = 'move';
      }

      function mouseup(e) {
        e.preventDefault();

        controls.enabled = true;

        if (intersected) {
          selected = null;
        }
      }

      renderer.domElement.addEventListener('mousemove', mousemove, false);
      renderer.domElement.addEventListener('mousedown', mousedown, false);
      renderer.domElement.addEventListener('mouseup', mouseup, false);

      //------------------------------------------------------------------
      // Animate and Render
      //------------------------------------------------------------------
      function animate() {
        requestAnimationFrame(animate);
        render();
      }

      function render() {
        controls.update();
        renderer.render(scene,camera);
      }

      container.appendChild(renderer.domElement);

      animate();

    </script>
  </body>
</html>