<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Blokus</title>
  <style>
    html { width: 100%; height: 100%; }
    body { margin: 0; overflow: hidden; width: 100%; height: 100%; }
    #canvas-container { width: 100%; height: 100%; }
    canvas { width: 100%; height: 100%; }
    #view-1 { position: fixed; top: 10px; left: 10px; }
    #view-2 { position: fixed; top: 10px; left: 60px; }
    #view-3 { position: fixed; top: 10px; left: 110px; }
  </style>
  <script src="bower_components/three.js/three.js"></script>
  <script src="TrackBallControls.js"></script>
  <script src="OBJLoader.js"></script>

  <script src="bower_components/tween.js/src/Tween.js"></script>
</head>
  <body>
    <div id="canvas-container">
      <button id="view-1">View 1</button>
      <button id="view-2">View 2</button>
      <button id="view-3">View 3</button>
    </div>
    <script>
      // TODO: TrackBallControlls and how it affects that camera views 1, 2, and 3...

      'use strict';

      var
        w = window,
        d = document,
        container = d.getElementById('canvas-container'),
        // three
        scene,
        camera,
        view1,
        view2,
        view3,
        renderer,
        directionalLight,
        ambientLight,
        raycaster,
        plane,
        offset,
        intersection,
        mouse,
        controls,
        loader,
        // game objects
        tableMesh,
        tableGeometry,
        tableMaterial,
        boardSquareMesh,
        boardSquareGeometryTemplate,
        boardSquareMaterial,
        group,
        squareMesh,
        squareGeometryTemplate,
        squareMaterial,
        // tweens
        rotationTween,
        // other
        i, l,
        j, jl,
        k, kl,
        board,
        hintBlock,
        boardSquareMeshHovered,
        blocks = [],
        intersected,
        selectedSquare,
        selectedBlock,
        color,
        colorAgent,
        colors = { // TODO: Replace with $rootScope.colors
          blue: {
            hex: 0x0000ff
          }, 
          green: {
            hex: 0x00ff00
          }, 
          yellow: {
            hex: 0xffff00
          }, 
          red: {
            hex: 0xff0000
          }
        },
        // dimensions
        WIDTH = container.offsetWidth,
        HEIGHT = container.offsetHeight,
        SQUARE_WIDTH = 0.2,
        SQUARE_HEIGHT = 0.2,
        SQUARE_DEPTH = 0.02,
        BOARD_WIDTH_IN_SQUARES = 20,
        BOARD_HEIGHT_IN_SQUARES = 20,
        TABLE_WIDTH = 10,
        TABLE_HEIGHT = 10;


      function loadOBJPromise(url) {
        return new Promise(function (resolve, reject) {
          var
            loader;

          loader = new THREE.OBJLoader();
          loader.load(
            // resource URL
            url,
            // Function when resource is loaded
            function (object) {
              resolve(object);
            }
          );
        });
          
      };

      Promise.all([
          loadOBJPromise('src/images/block-1.obj')
            .then(function (group) {
              squareGeometryTemplate = group.children[0].geometry;
            }),
          loadOBJPromise('src/images/BoardSquare.obj')
            .then(function (group) {
              boardSquareGeometryTemplate = group.children[0].geometry;
            })
        ])
        .then(function () {

          //------------------------------------------------------------------
          // renderer
          //------------------------------------------------------------------
          renderer = new THREE.WebGLRenderer();
          renderer.setSize(WIDTH, HEIGHT);
          renderer.setClearColor(0xffffff);
          renderer.shadowMap.enabled = true;

          //------------------------------------------------------------------
          // scene
          //------------------------------------------------------------------
          scene = new THREE.Scene();

          //------------------------------------------------------------------
          // camera
          //------------------------------------------------------------------
          camera = new THREE.PerspectiveCamera(
            45, 
            WIDTH/HEIGHT, 
            0.1, 
            1000
          );

          camera.position.x = 6;
          camera.position.y = 6;
          camera.position.z = 6;

          camera.rotation.x = 0;
          camera.rotation.y = 0;
          camera.rotation.z = 0;

          camera.lookAt(new THREE.Vector3(0,0,0));

          // listeners
          // TODO: Do views for:
          // - all corners - 4
          // - all sides - 4
          // - all rotations of to top view - 4

          view1 = d.getElementById('view-1');
          view2 = d.getElementById('view-2');
          view3 = d.getElementById('view-3');

          view1.addEventListener('click', function (evt) {
            camera.position.x = 0;
            camera.position.y = 10;
            camera.position.z = 0;

            camera.rotation.x = 0;
            camera.rotation.y = 0;
            camera.rotation.z = 0;

            camera.lookAt(new THREE.Vector3(0,0,0));
          });

          view2.addEventListener('click', function (evt) {
            camera.position.x = 0;
            camera.position.y = 6;
            camera.position.z = 9;

            camera.rotation.x = 0;
            camera.rotation.y = 0;
            camera.rotation.z = 0;
            
            camera.lookAt(new THREE.Vector3(0,0,0));
          });

          view3.addEventListener('click', function (evt) {
            camera.position.x = 6;
            camera.position.y = 6;
            camera.position.z = 6;

            camera.rotation.x = 0;
            camera.rotation.y = 0;
            camera.rotation.z = 0;
            
            camera.lookAt(new THREE.Vector3(0,0,0));
          });

          // resize if the window gets resized
          w.addEventListener('resize', function () {

            WIDTH = container.offsetWidth;
            HEIGHT = container.offsetHeight;
            
            // update the camera
            camera.aspect = WIDTH / HEIGHT;
            camera.updateProjectionMatrix();

            // update the renderer
            renderer.setSize(WIDTH, HEIGHT);
            
          }, false);

          //------------------------------------------------------------------
          // controls
          //------------------------------------------------------------------
          controls = new THREE.TrackballControls(camera);
          controls.rotateSpeed = 1.0;
          controls.zoomSpeed = 1.2;
          controls.panSpeed = 0.3;
          controls.noZoom = false;
          controls.noPan = false;
          controls.noRotate = false;
          controls.staticMoving = false;
          controls.dynamicDampingFactor = 0.3;

          //------------------------------------------------------------------
          // lights
          //------------------------------------------------------------------
          directionalLight = new THREE.DirectionalLight(0xffffff, 0.65);

          directionalLight.position.x = -50;
          directionalLight.position.y = 50;
          directionalLight.position.z = -50;

          directionalLight.castShadow = true;
          scene.add(directionalLight);

          ambientLight = new THREE.AmbientLight(0x505050);
          scene.add(ambientLight);

          //------------------------------------------------------------------
          // Table
          //------------------------------------------------------------------
          // tableGeometry = new THREE.PlaneGeometry(TABLE_WIDTH, TABLE_HEIGHT);
          // tableMaterial = new THREE.MeshStandardMaterial({
          //   color: 0xeeeeee,
          //   side: THREE.BackSide
          // });
          // tableMesh = new THREE.Mesh(tableGeometry, tableMaterial);

          // tableMesh.position.y = -1;

          // tableMesh.rotation.x = 0.5 * Math.PI;

          // tableMesh.castShadow = false;
          // tableMesh.receiveShadow = true;

          // scene.add(tableMesh);

          //------------------------------------------------------------------
          // Board
          //------------------------------------------------------------------
          board = [];
          //boardSquareGeometryTemplate = new THREE.PlaneGeometry(SQUARE_WIDTH, SQUARE_HEIGHT);

          for (i = 0, l = BOARD_WIDTH_IN_SQUARES; i < l; i++) {
            board[i] = [];

            for (j = 0, jl = BOARD_HEIGHT_IN_SQUARES; j < jl; j++) {
              boardSquareMaterial = new THREE.MeshPhongMaterial({
                color: 0xfcfcfc,
                shininess: 50,
                side: THREE.DoubleSide
              });
              boardSquareMesh = new THREE.Mesh(boardSquareGeometryTemplate, boardSquareMaterial);

              boardSquareMesh.position.x = (i * SQUARE_WIDTH) - ((BOARD_WIDTH_IN_SQUARES * SQUARE_WIDTH) / 2);
              boardSquareMesh.position.z = (j * SQUARE_HEIGHT) - ((BOARD_HEIGHT_IN_SQUARES * SQUARE_HEIGHT) / 2);

              // boardSquareMesh.rotation.x = 0.5 * Math.PI;

              boardSquareMesh.castShadow = true;
              boardSquareMesh.receiveShadow = false;

              boardSquareMesh.userData.xIndex = i;
              boardSquareMesh.userData.zIndex = j;
              boardSquareMesh.userData.block = null;
              boardSquareMesh.userData.square = null;

              board[i][j] = boardSquareMesh;
              scene.add(boardSquareMesh);
            }
          }

          //------------------------------------------------------------------
          // Blocks
          //------------------------------------------------------------------
          var 
            blockDefinitions = [
              //---------------------
              // 5 pieces
              //---------------------
              {
                startPosition: new THREE.Vector3(2.2, 0.1, 1.1),
                squareCount: 5,
                layout: [
                  [1,1,1,1,1]
                ]
              }, {
                startPosition: new THREE.Vector3(2.5, 0.1, 1.1),
                squareCount: 5,
                layout: [
                  [1,1,1,1],
                  [1,0,0,0]
                ]
              }, {
                startPosition: new THREE.Vector3(3.0, 0.1, 1.1),
                squareCount: 5,
                layout: [
                  [1,1,1,1],
                  [0,1,0,0]
                ]
              }, {
                startPosition: new THREE.Vector3(3.5, 0.1, 1.1),
                squareCount: 5,
                layout: [
                  [0,1,1,1],
                  [1,1,0,0]
                ]
              }, {
                startPosition: new THREE.Vector3(2.2, 0.1, 0.4),
                squareCount: 5,
                layout: [
                  [1,1,1],
                  [1,0,0],
                  [1,0,0]
                ]
              }, {
                startPosition: new THREE.Vector3(2.9, 0.1, 0.4),
                squareCount: 5,
                layout: [
                  [0,1,1],
                  [1,1,0],
                  [1,0,0]
                ]
              }, {
                startPosition: new THREE.Vector3(3.6, 0.1, 0.4),
                squareCount: 5,
                layout: [
                  [0,1,1],
                  [0,1,0],
                  [1,1,0]
                ]
              }, {
                startPosition: new THREE.Vector3(2.2, 0.1, -0.3),
                squareCount: 5,
                layout: [
                  [1,1,1],
                  [0,1,0],
                  [0,1,0]
                ]
              }, {
                startPosition: new THREE.Vector3(2.9, 0.1, -0.3),
                squareCount: 5,
                layout: [
                  [0,1,1],
                  [1,1,0],
                  [0,1,0]
                ]
              }, {
                startPosition: new THREE.Vector3(3.6, 0.1, -0.3),
                squareCount: 5,
                layout: [
                  [0,1,0],
                  [1,1,1],
                  [0,1,0]
                ]
              }, {
                startPosition: new THREE.Vector3(4.0, 0.1, 1.3),
                squareCount: 5,
                layout: [
                  [1,1,1],
                  [1,1,0]
                ]
              }, {
                startPosition: new THREE.Vector3(4.3, 0.1, 0.4),
                squareCount: 5,
                layout: [
                  [1,1,1],
                  [1,0,1]
                ]
              },
              //---------------------
              // 4 pieces
              //---------------------
              {
                startPosition: new THREE.Vector3(2.2, 0.1, -1.2),
                squareCount: 4,
                layout: [
                  [1,1,1,1]
                ]
              }, {
                startPosition: new THREE.Vector3(2.5, 0.1, -1.2),
                squareCount: 4,
                layout: [
                  [1,1,1],
                  [1,0,0]
                ]
              }, {
                startPosition: new THREE.Vector3(3.0, 0.1, -1.2),
                squareCount: 4,
                layout: [
                  [1,1,1],
                  [0,1,0]
                ]
              }, {
                startPosition: new THREE.Vector3(3.5, 0.1, -1.2),
                squareCount: 4,
                layout: [
                  [1,1,0],
                  [0,1,1]
                ]
              }, {
                startPosition: new THREE.Vector3(4.0, 0.1, -1.2),
                squareCount: 4,
                layout: [
                  [1,1],
                  [1,1]
                ]
              },
              //---------------------
              // 3 pieces
              //---------------------
              {
                startPosition: new THREE.Vector3(2.2, 0.1, -1.9),
                squareCount: 3,
                layout: [
                  [1,1,1]
                ]
              }, {
                startPosition: new THREE.Vector3(2.5, 0.1, -1.9),
                squareCount: 3,
                layout: [
                  [1,1],
                  [1,0]
                ]
              },
              //---------------------
              // 2 pieces
              //---------------------
              {
                startPosition: new THREE.Vector3(3.0, 0.1, -1.9),
                squareCount: 2,
                layout: [
                  [1,1]
                ]
              },
              //---------------------
              // 1 pieces
              //---------------------
              {
                startPosition: new THREE.Vector3(3.3, 0.1, -1.9),
                squareCount: 1,
                layout: [
                  [1]
                ]
              }
            ],
            block,
            blockDefinition,
            row,
            square;

          for (color in colors) {
            colorAgent = colors[color];
            // TODO: find out who has which color

            for (k = 0, kl = blockDefinitions.length; k < kl; k++) {
              blockDefinition = blockDefinitions[k];

              block = new THREE.Group();

              block.userData.layout = blockDefinition.layout;
              block.userData.squareCount = blockDefinition.squareCount;
              block.userData.colorAgent = colorAgent;

              for (i = 0, l = blockDefinition.layout.length; i < l; i++) {
                row = blockDefinition.layout[i];

                for (j = 0, jl = row.length; j < jl; j++) {
                  square = row[j];

                  if (square) {
                    //squareGeometryTemplate = new THREE.BoxGeometry(SQUARE_WIDTH, SQUARE_DEPTH, SQUARE_HEIGHT);
                    squareMaterial = new THREE.MeshPhongMaterial({
                      color: block.userData.colorAgent.hex,
                      transparent: true,
                      opacity: 0.75,
                      shininess: 75,
                      side: THREE.DoubleSide
                    });
                    squareMesh = new THREE.Mesh(squareGeometryTemplate, squareMaterial);

                    squareMesh.position.x = i * SQUARE_WIDTH;
                    squareMesh.position.z = j * SQUARE_HEIGHT;

                    squareMesh.userData.xIndex = i;
                    squareMesh.userData.zIndex = j;

                    block.add(squareMesh);
                  }

                }
              }

              block.startPosition = new THREE.Vector3();
              block.startRotation = new THREE.Vector3();

              if (color === 'blue') {
                block.startPosition.x = blockDefinition.startPosition.x;
                block.startPosition.y = blockDefinition.startPosition.y;
                block.startPosition.z = blockDefinition.startPosition.z;

                block.startRotation.y = 0;
              } else if (color === 'green') {
                block.startPosition.x = -blockDefinition.startPosition.x;
                block.startPosition.y = blockDefinition.startPosition.y;
                block.startPosition.z = -blockDefinition.startPosition.z;

                block.startRotation.y = Math.PI;
              } else if (color === 'red') {
                block.startPosition.x = -blockDefinition.startPosition.z;
                block.startPosition.y = blockDefinition.startPosition.y;
                block.startPosition.z = blockDefinition.startPosition.x;

                block.startRotation.y = Math.PI + Math.PI / 2;
              } else if (color === 'yellow') {
                block.startPosition.x = blockDefinition.startPosition.z;
                block.startPosition.y = blockDefinition.startPosition.y;
                block.startPosition.z = -blockDefinition.startPosition.x;

                block.startRotation.y = Math.PI / 2;
              }

              block.position.x = block.startPosition.x;
              block.position.y = block.startPosition.y;
              block.position.z = block.startPosition.z;

              block.rotation.y = block.startRotation.y;

              block.castShadow = true;
              block.receiveShadow = false;

              blocks.push(block);

              scene.add(block);
            }

          }
            
          //------------------------------------------------------------------
          // Square with custom mesh
          //------------------------------------------------------------------
          // loader = new THREE.OBJLoader();
          // loader.load(
          //   // resource URL
          //   'src/images/block-1.obj',
          //   // Function when resource is loaded
          //   function (object) {
          //     console.log(object);

          //     squareMesh = object.children[0];
          //     squareMesh.material = new THREE.MeshPhongMaterial({
          //       color: 0xff0000,
          //       transparent: true,
          //       opacity: 0.65,
          //       shininess: 75,
          //       side: THREE.DoubleSide
          //     });

          //     squareMesh.position.y = 0.1;
          //     squareMesh.position.x = 2.2;
          //     squareMesh.position.z = 0;

          //     squareMesh.castShadow = true;
          //     squareMesh.receiveShadow = false;

          //     hoverables.push(squareMesh);
          //     selectables.push(squareMesh);

          //     scene.add(squareMesh);
          //   }
          // );


          //------------------------------------------------------------------
          // Interaction
          //------------------------------------------------------------------
          raycaster = new THREE.Raycaster();
          mouse = new THREE.Vector2();
          plane = new THREE.Plane(new THREE.Vector3(0, 1, 0));
          offset = new THREE.Vector3();
          intersection = new THREE.Vector3();

          function mousemove(e) {
            var
              intersect,
              intersects,
              i, l,
              xIndex, zIndex,
              hoverable;

            e.preventDefault();

            mouse.x = (event.clientX / WIDTH) * 2 - 1;
            mouse.y = -(event.clientY / HEIGHT) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            if (selectedSquare && selectedBlock) {
              
              // move along the x and z plane
              if (raycaster.ray.intersectPlane(plane, intersection)) {
                selectedBlock.position.copy(intersection.sub(offset));

                xIndex = Math.floor((intersection.x + ((BOARD_WIDTH_IN_SQUARES * SQUARE_WIDTH) / 2) + (SQUARE_WIDTH / 2)) / SQUARE_WIDTH);
                zIndex = Math.floor((intersection.z + ((BOARD_HEIGHT_IN_SQUARES * SQUARE_HEIGHT) / 2) + (SQUARE_HEIGHT / 2)) / SQUARE_HEIGHT);

                scene.remove(hintBlock);

                // reset previous hover
                // if (boardSquareMeshHovered) {
                //   boardSquareMeshHovered.material.color = boardSquareMeshHovered.previousColor;
                // }

                if (
                  board[xIndex] &&
                  board[xIndex][zIndex]
                ) {
                  boardSquareMeshHovered = board[xIndex][zIndex];

                  // boardSquareMeshHovered.previousColor = boardSquareMeshHovered.material.color;
                  // boardSquareMeshHovered.material.color = new THREE.Color(0xff0000);

                  // show the hint
                  hintBlock = selectedBlock.clone();

                  hintBlock.position.copy(boardSquareMeshHovered.position);

                  scene.add(hintBlock);
                }

              }

            } else {
              // TODO: Transform an object when hovered

              intersects = raycaster.intersectObjects(blocks, true);

              if (intersects.length > 0) {
                intersect = intersects[0];

                if (intersect.object.parent) {
                  intersected = intersect.object.parent;
                } else {
                  intersected = intersect.object;
                }

                container.style.cursor = 'pointer';

              } else {
                intersected = null;

                container.style.cursor = 'auto';
              }
            }
              
          }

          function mousedown(e) {
            var
              intersect,
              intersects;

            e.preventDefault();

            // NOTE: mouse.x and mouse.y should already be set because it was set above

            raycaster.setFromCamera(mouse, camera);

            intersects = raycaster.intersectObjects(blocks, true);

            if (intersects.length > 0) {
              intersect = intersects[0];

              // disable zoom, pan, etc. while dragging
              controls.enabled = false;

              selectedSquare = intersect.object;
              if (intersect.object.parent) {
                selectedBlock = intersect.object.parent;
              }

              if (raycaster.ray.intersectPlane(plane, intersection)) {
                offset.copy(intersection).sub(selectedBlock.position);
              }
            }

            container.style.cursor = 'move';
          }

          function mouseup(e) {
            e.preventDefault();

            controls.enabled = true;

            if (intersected) {
              selectedSquare = null;
              selectedBlock = null;
            }
          }

          function keydown(e) {
            var
              xRotation,
              zRotation,
              yRotation;

            e.preventDefault();

            if (selectedBlock && !rotationTween) {

              // left
              if (e.keyCode === 37) {

                yRotation = selectedBlock.rotation.y;

                rotationTween = new TWEEN.Tween(selectedBlock.rotation)
                  .easing(TWEEN.Easing.Exponential.Out)
                  .to({y: yRotation + Math.PI/2}, 200)
                  .onComplete(function () {
                    rotationTween = null;

                    // TODO: Update the layout of the group
                  })
                  .start();

              // up
              } else if (e.keyCode === 38) {

                xRotation = selectedBlock.rotation.x;

                rotationTween = new TWEEN.Tween(selectedBlock.rotation)
                  .easing(TWEEN.Easing.Exponential.Out)
                  .to({x: xRotation + Math.PI}, 200)
                  .onComplete(function () {
                    rotationTween = null;

                    // TODO: Update the layout of the group
                  })
                  .start();

              // right
              } else if (e.keyCode === 39) {

                yRotation = selectedBlock.rotation.y;

                rotationTween = new TWEEN.Tween(selectedBlock.rotation)
                  .easing(TWEEN.Easing.Exponential.Out)
                  .to({y: yRotation - Math.PI/2}, 200)
                  .onComplete(function () {
                    rotationTween = null;

                    // TODO: Update the layout of the group
                  })
                  .start();

              // down
              } else if (e.keyCode === 40) {

                zRotation = selectedBlock.rotation.z;

                rotationTween = new TWEEN.Tween(selectedBlock.rotation)
                  .easing(TWEEN.Easing.Exponential.Out)
                  .to({z: zRotation - Math.PI}, 200)
                  .onComplete(function () {
                    rotationTween = null;

                    // TODO: Update the layout of the group
                  })
                  .start();
              }

              
            }

          }

          renderer.domElement.addEventListener('mousemove', mousemove, false);
          renderer.domElement.addEventListener('mousedown', mousedown, false);
          renderer.domElement.addEventListener('mouseup', mouseup, false);
          document.addEventListener('keydown', keydown, false);

          //------------------------------------------------------------------
          // Animate and Render
          //------------------------------------------------------------------
          function animate(time) {
            requestAnimationFrame(animate);

            TWEEN.update(time);
            render();
          }

          function render() {
            controls.update();
            renderer.render(scene,camera);
          }

          container.appendChild(renderer.domElement);

          animate();
        });

      

    </script>
  </body>
</html>